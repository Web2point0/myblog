<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Meet Up (Auto-Match + Auto-Host)</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    background: #111;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    margin: 0;
    padding: 20px;
  }
  h2 {
    margin-bottom: 10px;
    text-align: center;
  }
  #status {
    margin-bottom: 15px;
    font-weight: bold;
  }
  .video-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 10px;
    width: 100%;
    max-width: 900px;
  }
  .video-box {
    position: relative;
    flex: 1 1 300px;
    max-width: 420px;
    aspect-ratio: 16 / 9;
    background: #000;
    border-radius: 10px;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  button {
    margin-top: 15px;
    padding: 12px 20px;
    font-weight: bold;
    border: none;
    border-radius: 6px;
    background: #0b84ff;
    color: #fff;
    cursor: pointer;
    font-size: 16px;
  }
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  @media (max-width: 700px) {
    .video-container { flex-direction: column; }
    .video-box {
      width: 90%;
      max-width: 500px;
      aspect-ratio: 4 / 3;
    }
  }
</style>
</head>
<body>
  <h2>Meet Up</h2>
  <div id="status">Connecting to PeerJS...</div>

  <div class="video-container">
    <div class="video-box">
      <video id="myVideo" autoplay muted playsinline></video>
    </div>
    <div class="video-box">
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <button id="nextBtn" disabled>Next Partner</button>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
    // === CONFIGURE METERED TURN/STUN ===
    const iceServers = [
      {
        urls: [
          "stun:stun.metered.ca:80",
          "turn:turn.metered.ca:80",
          "turn:turn.metered.ca:443",
          "turns:turn.metered.ca:443"
        ],
        username: "YOUR_METERED_USERNAME",
        credential: "YOUR_METERED_PASSWORD"
      }
    ];

    // === GLOBALS ===
    const ROOM_HOST_ID = "public-room-host";
    const statusEl = document.getElementById("status");
    const myVideo = document.getElementById("myVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const nextBtn = document.getElementById("nextBtn");

    let peer, myId, hostId, isHost = false;
    let connToHost, currentCall, connectedPartner = null;
    let myStream = null;
    const queue = []; // host only

    // === INIT PEER ===
    peer = new Peer({
      host: "0.peerjs.com",
      port: 443,
      secure: true,
      config: { iceServers }
    });

    peer.on("open", id => {
      myId = id;
      statusEl.textContent = "Connected. Your ID: " + id;
      checkHostStatus();
    });

    // === AUTO HOST RECOVERY ===
    async function checkHostStatus() {
      try {
        const test = await fetch(`https://0.peerjs.com/peerjs/${ROOM_HOST_ID}/id`, { method: "GET" });
        if (test.status !== 200) throw new Error("Not found");
        // If reachable, connect as client
        hostId = ROOM_HOST_ID;
        connectToHost();
      } catch (err) {
        // Host not found â†’ become host
        becomeHost();
      }
    }

    // === HOST LOGIC ===
    function becomeHost() {
      isHost = true;
      peer.destroy();
      peer = new Peer(ROOM_HOST_ID, {
        host: "0.peerjs.com",
        port: 443,
        secure: true,
        config: { iceServers }
      });
      peer.on("open", () => {
        statusEl.textContent = "You are the host. Waiting for visitors...";
        setupHost();
      });
    }

    function setupHost() {
      peer.on("connection", conn => {
        conn.on("data", msg => {
          if (msg.type === "joinQueue") {
            queue.push(conn);
            maybePair();
          }
        });
      });
    }

    function maybePair() {
      while (queue.length >= 2) {
        const aConn = queue.shift();
        const bConn = queue.shift();
        aConn.send({ type: "partner", id: bConn.peer });
        bConn.send({ type: "partner", id: aConn.peer });
      }
    }

    // === CLIENT CONNECTION ===
    function connectToHost() {
      connToHost = peer.connect(ROOM_HOST_ID);
      connToHost.on("open", () => {
        nextBtn.disabled = false;
        statusEl.textContent = "Connected to host. Click 'Next Partner' to start.";
      });
      connToHost.on("data", msg => {
        if (msg.type === "partner") connectToPartner(msg.id);
      });
    }

    // === MEDIA STREAM ===
    async function startMyStream() {
      if (myStream) return;
      try {
        myStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        myVideo.srcObject = myStream;
      } catch (err) {
        alert("Camera/mic permission required: " + err);
      }
    }

    function stopStreams() {
      if (myStream) {
        myStream.getTracks().forEach(track => track.stop());
        myStream = null;
      }
      remoteVideo.srcObject = null;
    }

    // === CONNECT TO PARTNER ===
    function connectToPartner(partnerId) {
      startMyStream();
      statusEl.textContent = "Connecting to partner...";
      const call = peer.call(partnerId, myStream);
      currentCall = call;
      connectedPartner = partnerId;

      call.on("stream", stream => {
        remoteVideo.srcObject = stream;
        statusEl.textContent = "Connected! Click 'Next Partner' anytime.";
        nextBtn.disabled = false;
      });
      call.on("close", handleDisconnect);
      call.on("error", handleDisconnect);
    }

    // === INCOMING CALL ===
    peer.on("call", call => {
      startMyStream();
      call.answer(myStream);
      currentCall = call;
      connectedPartner = call.peer;
      call.on("stream", stream => {
        remoteVideo.srcObject = stream;
        statusEl.textContent = "Connected! Click 'Next Partner' anytime.";
        nextBtn.disabled = false;
      });
      call.on("close", handleDisconnect);
    });

    // === MUTUAL DISCONNECT HANDLING ===
    peer.on("connection", conn => {
      conn.on("data", data => {
        if (data.type === "disconnect") {
          if (currentCall) currentCall.close();
          connectedPartner = null;
          remoteVideo.srcObject = null;
          statusEl.textContent = "Your partner left. Click 'Next Partner' to find someone new.";
        }
      });
    });

    function handleDisconnect() {
      connectedPartner = null;
      remoteVideo.srcObject = null;
      statusEl.textContent = "Partner disconnected. Click 'Next Partner' to continue.";
    }

    // === NEXT PARTNER BUTTON ===
    nextBtn.onclick = async () => {
      // Notify and close previous connection
      if (currentCall && connectedPartner) {
        try {
          const dc = peer.connect(connectedPartner);
          dc.on("open", () => {
            dc.send({ type: "disconnect" });
            dc.close();
          });
        } catch (err) { console.warn("Couldn't notify partner of disconnect:", err); }
        currentCall.close();
        currentCall = null;
        connectedPartner = null;
        remoteVideo.srcObject = null;
      }

      await startMyStream();

      if (!connToHost || !connToHost.open) {
        connToHost = peer.connect(ROOM_HOST_ID);
        connToHost.on("open", () => {
          connToHost.send({ type: "joinQueue" });
          statusEl.textContent = "Waiting for next partner...";
        });
        connToHost.on("data", msg => {
          if (msg.type === "partner") connectToPartner(msg.id);
        });
      } else {
        connToHost.send({ type: "joinQueue" });
        statusEl.textContent = "Waiting for next partner...";
      }
    };
  </script>
</body>
</html>
